#!/usr/bin/env python

import exceptions, untwisted
from testify import *
from untwisted import event

class Exception(exceptions.Exception):
  pass

# Call then throw

sample = event.event()
equal(sample('Call then throw'), sample)

try:
  ok(False, sample.throw(Exception('Call then throw')))

except StopIteration:
  pass

# Connect
sample = event.event()
equal(sample.connect('Connect'), sample)

# Throw then call

sample = event.event()
equal(sample.throw(Exception('Throw then call')), sample)

try:
  ok(False, sample('Throw then call'))

except StopIteration:
  pass

# Suppress traceback

@sample.connect
class ignore:

  @staticmethod
  def throw(*args, **kwds):
    pass

@test
def connectThenCall():
  expect(1)

  sample = event.event()

  sample.connect(untwisted.callback(lambda: equal((yield), 'Connect then call')))

  sample('Connect then call')

@test
def callThenConnect():
  expect(1)

  sample = event.event()
  sample('Call then connect')

  sample.connect(untwisted.callback(lambda: equal((yield), 'Call then connect')))

@test
def connectThenThrow():
  expect(1)

  sample = event.event()

  @sample.connect
  @untwisted.callback
  def ignore():
    try:
      ok(False, (yield))

    except Exception:
      ok(True)

  sample.throw(Exception('Connect then throw'))

@test
def throwThenConnect():
  expect(1)

  sample = event.event()
  sample.throw(Exception('Throw then connect'))

  @sample.connect
  @untwisted.callback
  def ignore():
    try:
      ok(False, (yield))

    except Exception:
      ok(True)

@test
def chain():
  expect(1)

  sample = event.event()
  event.event()('Chain').connect(sample)

  sample.connect(untwisted.callback(lambda: equal((yield), 'Chain')))

@test
def callWithEvent():
  expect(1)

  sample = event.event()(event.event()('Call with event'))

  sample.connect(untwisted.callback(lambda: equal((yield), 'Call with event')))

@test
def returnEvent():
  expect(1)

  sample = event.event()('Call').connect(lambda *args, **kwds: event.event()('Return event'))

  sample.connect(untwisted.callback(lambda: equal((yield), 'Return event')))
